## API Report File for "@vue-composable/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { Ref } from "@vue/composition-api";

// @public (undocumented)
export interface ArrayPaginationResult<T extends Array<any>>
  extends PaginationResult {
  // (undocumented)
  result: Readonly<Ref<T>>;
}

// Warning: (ae-forgotten-export) The symbol "i18nDefinition" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "i18nResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function buildI18n<
  T extends i18nDefinition<TMessage>,
  TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>
>(definition: T): i18nResult<keyof T["messages"], T["messages"][T["locale"]]>;

// @public (undocumented)
export interface CancellablePromiseResult<TCancel = any> {
  // (undocumented)
  cancel: (result?: TCancel) => void;
  // (undocumented)
  cancelled: Ref<boolean>;
}

// @public (undocumented)
export function debounce<F extends Procedure>(
  func: F,
  waitMilliseconds?: number,
  options?: Options
): F;

// @public (undocumented)
export function deepClone<T extends object = object>(
  result: T,
  ...sources: T[]
): T;

// Warning: (ae-forgotten-export) The symbol "RetryDelayFactory" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const exponentialDelay: RetryDelayFactory;

// @public (undocumented)
export const FALSE_OP: () => boolean;

// @public (undocumented)
export interface FormatObject {
  // (undocumented)
  [id: string]: FormatValue;
}

// @public (undocumented)
export type FormatValue =
  | RefTyped<object>
  | RefTyped<string>
  | RefTyped<number>;

// Warning: (ae-forgotten-export) The symbol "i18nMessageValue" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface i18n extends Record<string, i18nMessageValue> {}

// @public (undocumented)
export const isArray: (arg: any) => arg is any[];

// @public (undocumented)
export const isBoolean: (val: unknown) => val is Boolean;

// @public (undocumented)
export const isClient: boolean;

// @public (undocumented)
export const isDate: (val: unknown) => val is Date;

// @public (undocumented)
export const isElement: (val: unknown) => val is Element;

// @public (undocumented)
export const isFunction: (val: unknown) => val is Function;

// @public (undocumented)
export const isNumber: (val: unknown) => val is number;

// @public (undocumented)
export const isObject: (val: unknown) => val is Record<any, any>;

// @public (undocumented)
export function isPromise<T = any>(val: unknown): val is Promise<T>;

// @public (undocumented)
export const isString: (val: unknown) => val is string;

// @public (undocumented)
export const isSymbol: (val: unknown) => val is symbol;

// @public (undocumented)
export function minMax(val: number, min: number, max: number): number;

// @public (undocumented)
export const NO_OP: () => void;

// @public (undocumented)
export const noDelay: RetryDelayFactory;

// @public (undocumented)
export interface NowOptions {
  refreshMs?: number;
  sync?: boolean;
}

// @public (undocumented)
export type Options = {
  isImmediate: boolean;
};

// @public (undocumented)
export interface PaginationOptions {
  // (undocumented)
  currentPage: RefTyped<number>;
  // (undocumented)
  pageSize: RefTyped<number>;
  // (undocumented)
  total: RefTyped<number>;
}

// @public (undocumented)
export interface PaginationResult {
  // (undocumented)
  currentPage: Ref<number>;
  // (undocumented)
  first: PaginationControl;
  // (undocumented)
  last: PaginationControl;
  // (undocumented)
  lastPage: Readonly<Ref<number>>;
  // Warning: (ae-forgotten-export) The symbol "PaginationControl" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  next: PaginationControl;
  // (undocumented)
  offset: Ref<number>;
  // (undocumented)
  pageSize: Ref<number>;
  // (undocumented)
  prev: PaginationControl;
  // (undocumented)
  total: Ref<number>;
}

// @public (undocumented)
export const PASSIVE_EV: AddEventListenerOptions;

// @public
export type Procedure = (...args: any[]) => void;

// @public (undocumented)
export function promisedTimeout(timeout: number): Promise<void>;

// Warning: (ae-forgotten-export) The symbol "PromiseResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface PromiseResultFactory<
  T extends Promise<any>,
  TArgs extends Array<any> = Array<any>
> extends PromiseResult<T> {
  // Warning: (ae-forgotten-export) The symbol "PromiseType" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  exec: (...args: TArgs) => Promise<PromiseType<T> | undefined>;
}

// @public (undocumented)
export type RefElement = Element | Ref<Element | undefined>;

// @public (undocumented)
export type RefTyped<T> = T | Ref<T>;

// Warning: (ae-forgotten-export) The symbol "RetryReturn" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface RetryReturnFactory<T, TArgs extends Array<any>>
  extends RetryReturn {
  exec(...args: TArgs): T;
}

// @public (undocumented)
export interface RetryReturnNoFactory extends RetryReturn {
  exec<T>(fn: () => T): T;
}

// @public (undocumented)
export function setI18n<
  T extends i18nDefinition<TMessage>,
  TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>
>(definition: T): i18nResult<keyof T["messages"], T["messages"][T["locale"]]>;

// @public (undocumented)
export function unwrap(o: RefElement): Element;

// @public (undocumented)
export function unwrap<T>(o: RefTyped<T>): T;

// @public (undocumented)
export type UnwrapRef<T> = T extends Ref<infer R> ? R : T;

// @public (undocumented)
export function useArrayPagination<T extends Array<TR>, TR>(
  array: RefTyped<T>,
  options?: Partial<Omit<PaginationOptions, "total">>
): ArrayPaginationResult<T>;

// @public (undocumented)
export function useCancellablePromise<T extends any, TArgs extends Array<any>>(
  fn: (...args: TArgs) => Promise<T>
): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any, TArgs extends Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  throwException: boolean
): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any>(
  fn: () => T
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any>(
  fn: () => T,
  throwException: boolean
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<
  T extends Promise<TR>,
  TR,
  TArgs extends Array<any>
>(
  fn: (...args: TArgs) => T
): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<
  T extends Promise<TR>,
  TR,
  TArgs extends Array<any>
>(
  fn: (...args: TArgs) => T,
  throwException: boolean
): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T = any>(
  fn: () => T
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T = any>(
  fn: () => T,
  throwException: boolean
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends Promise<TR>, TR>(
  fn: () => T
): PromiseResultFactory<T> & CancellablePromiseResult;

// @public (undocumented)
export function useDateNow(
  options?: NowOptions
): {
  now: import("@vue/composition-api").Ref<number>;
  remove: () => void;
};

// @public (undocumented)
export function useDebounce<T extends Function>(
  handler: T,
  wait?: number,
  options?: Options
): T;

// @public (undocumented)
export function useFormat(
  format: Readonly<RefTyped<string>>,
  obj?: RefTyped<FormatObject>
): Readonly<Ref<string>>;

// @public (undocumented)
export function useFormat(
  format: Readonly<RefTyped<string>>,
  ...args: Array<FormatValue>
): Readonly<Ref<string>>;

// @public (undocumented)
export function useFormat(
  format: Readonly<RefTyped<string>>,
  obj?: RefTyped<FormatObject> | Array<FormatValue>
): Readonly<Ref<string>>;

// @public (undocumented)
export function useI18n<
  T extends i18nDefinition<TMessage>,
  TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>
>(definition: T): i18nResult<keyof T["messages"], T["messages"][T["locale"]]>;

// @public (undocumented)
export function useI18n<T = i18n>(): i18nResult<string[], T> | void;

// @public (undocumented)
export function useNow(
  options?: NowOptions & UseNowOptions
): {
  now: import("@vue/composition-api").Ref<number>;
  remove: () => void;
};

// @public (undocumented)
export interface UseNowOptions {
  timeFn?: () => number;
}

// @public (undocumented)
export function usePagination(options: PaginationOptions): PaginationResult;

// @public (undocumented)
export function usePath<T extends object = any>(
  source: RefTyped<T>,
  path: RefTyped<string>,
  separator?: string,
  notFoundReturn?: UsePathNotFoundReturn
): Readonly<import("@vue/composition-api").Ref<Readonly<any>>>;

// @public (undocumented)
export type UsePathNotFoundReturn = (
  path: string,
  source: any,
  fullPath: string,
  originalSource: any
) => any;

// @public (undocumented)
export function usePerformanceNow(
  options?: NowOptions
): {
  now: import("@vue/composition-api").Ref<number>;
  remove: () => void;
};

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  throwException?: boolean
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T,
  throwException: boolean
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => Promise<T>,
  throwException: boolean
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => Promise<T>
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => T,
  throwException: boolean
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => T
): PromiseResultFactory<Promise<T>>;

// Warning: (ae-forgotten-export) The symbol "RetryOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useRetry(options?: RetryOptions): RetryReturnNoFactory;

// Warning: (ae-forgotten-export) The symbol "Factory" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useRetry<T, TArgs extends Array<any>>(
  factory: Factory<T, TArgs>
): RetryReturnFactory<T, TArgs>;

// @public (undocumented)
export function useRetry<T, TArgs extends Array<any>>(
  options: RetryOptions,
  factory: Factory<T, TArgs>
): RetryReturnFactory<T, TArgs>;

// Warning: (ae-forgotten-export) The symbol "UseValidation" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ValidationOutput" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ValidationGroupResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useValidation<T extends UseValidation<E>, E = any>(
  input: E
): ValidationOutput<E> & ValidationGroupResult;

// @public (undocumented)
export function wrap(o: RefElement): Ref<Element>;

// @public (undocumented)
export function wrap<T>(o: RefTyped<T>): Ref<T>;

// @public (undocumented)
export type WrapRef<T> = T extends Ref<any> ? T : Ref<T>;

// (No @packageDocumentation comment for this package)
```
