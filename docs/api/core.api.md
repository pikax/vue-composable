## API Report File for "@vue-composable/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { ComputedRef } from "@vue/runtime-core";
import { Ref } from "@vue/runtime-core";
import { UnwrapRef } from "@vue/runtime-core";

// @public (undocumented)
export interface ArrayPaginationResult<T extends Array<any>>
  extends PaginationResult {
  // (undocumented)
  result: ComputedRef<T>;
}

// Warning: (ae-forgotten-export) The symbol "I18nExtractLocale" needs to be exported by the entry point index.d.ts
//
// @public
export function buildI18n<
  T extends i18nDefinition<TMessage>,
  TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>
>(
  definition: T
): i18nResult<
  keyof T["messages"],
  I18nExtractLocale<T["messages"][T["locale"]]>
>;

// @public (undocumented)
export interface CancellablePromiseResult<TCancel = any> {
  // (undocumented)
  cancel: (result?: TCancel) => void;
  // (undocumented)
  cancelled: Ref<boolean>;
}

// @public (undocumented)
export function debounce<F extends Procedure>(
  func: F,
  waitMilliseconds?: number,
  options?: Options
): F;

// @public (undocumented)
export function deepClone<T extends object = object>(
  result: T,
  ...sources: T[]
): T;

// Warning: (ae-forgotten-export) The symbol "RetryDelayFactory" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const exponentialDelay: RetryDelayFactory;

// @public (undocumented)
export const FALSE_OP: () => boolean;

// @public (undocumented)
export interface FormatObject {
  // (undocumented)
  [id: string]: FormatValue;
}

// @public (undocumented)
export type FormatValue =
  | RefTyped<object>
  | RefTyped<string>
  | RefTyped<number>;

// @public
export interface i18n extends Record<string, i18nMessageValue> {}

// @public
export interface i18nDefinition<TMessage> {
  fallback?: keyof TMessage;
  locale: keyof TMessage;
  messages: {
    [K in keyof TMessage]: i18n | (() => Promise<i18n>) | (() => i18n);
  };
  notFoundFallback?: boolean;
  resolve?: i18nResolver;
}

// @public
export type i18nLocale<T> = {
  [K in keyof T]: i18nMessage<T[K]>;
};

// @public
export type i18nMessage<T> = T extends Ref<string>
  ? string
  : T extends () => Promise<infer P>
  ? i18nLocale<P>
  : T extends (...args: infer TArgs) => RefTyped<string>
  ? (...args: TArgs) => string
  : T extends object
  ? i18nLocale<T>
  : T extends Ref<infer V>
  ? V
  : T;

// @public
export type i18nMessageValue = i18nLocale<any> | RefTyped<string>;

// @public
export type i18nResolver = (
  i18n: i18n,
  path: Readonly<RefTyped<string>>,
  args: RefTyped<FormatObject> | Array<FormatValue> | undefined
) => RefTyped<string>;

// @public
export interface i18nResult<TLocales, TMessages extends any = i18n> {
  $t(path: string, args?: object | Array<object>): Readonly<Ref<string>>;
  $ts(path: string, args?: object | Array<object>): string;
  // (undocumented)
  addLocale(locale: string, messages: TMessages): void;
  i18n: Readonly<Ref<Readonly<TMessages>>>;
  locale: Ref<TLocales>;
  locales: Readonly<Ref<Readonly<Array<TLocales>>>>;
  removeLocale(locale: TLocales): void;
}

// @public (undocumented)
export const isArray: (arg: any) => arg is any[];

// @public (undocumented)
export const isBoolean: (val: unknown) => val is Boolean;

// @public (undocumented)
export const isClient: boolean;

// @public (undocumented)
export const isDate: (val: unknown) => val is Date;

// @public (undocumented)
export const isElement: (val: unknown) => val is Element;

// @public (undocumented)
export const isFunction: (val: unknown) => val is Function;

// @public (undocumented)
export const isNumber: (val: unknown) => val is number;

// @public (undocumented)
export const isObject: (val: unknown) => val is Record<any, any>;

// @public (undocumented)
export function isPromise<T = any>(val: unknown): val is Promise<T>;

// @public (undocumented)
export const isString: (val: unknown) => val is string;

// @public (undocumented)
export const isSymbol: (val: unknown) => val is symbol;

// @public (undocumented)
export function minMax(val: number, min: number, max: number): number;

// @public (undocumented)
export const NO_OP: () => void;

// @public (undocumented)
export const noDelay: RetryDelayFactory;

// @public (undocumented)
export interface NowOptions {
  refreshMs?: number;
  sync?: boolean;
}

// @public (undocumented)
export type Options = {
  isImmediate: boolean;
};

// @public
export type PaginationControl = () => void;

// @public
export interface PaginationOptions {
  currentPage: RefTyped<number>;
  pageSize: RefTyped<number>;
  total: RefTyped<number>;
}

// @public
export interface PaginationResult {
  currentPage: Ref<number>;
  first: PaginationControl;
  last: PaginationControl;
  lastPage: Readonly<Ref<number>>;
  next: PaginationControl;
  offset: Ref<number>;
  pageSize: Ref<number>;
  prev: PaginationControl;
  total: Readonly<Ref<Readonly<number>>>;
}

// @public (undocumented)
export const PASSIVE_EV: AddEventListenerOptions;

// @public
export type Procedure = (...args: any[]) => void;

// @public (undocumented)
export function promisedTimeout(timeout: number): Promise<void>;

// @public (undocumented)
export interface PromiseOptions {
  lazy?: boolean;
  throwException?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "PromiseResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface PromiseResultFactory<
  T extends Promise<any>,
  TArgs extends Array<any> = Array<any>
> extends PromiseResult<T> {
  // Warning: (ae-forgotten-export) The symbol "PromiseType" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  exec: (...args: TArgs) => Promise<PromiseType<T> | undefined>;
}

// @public (undocumented)
export type RefElement = Element | Ref<Element | undefined>;

// @public (undocumented)
export type RefTyped<T> = T | Ref<T>;

// Warning: (ae-forgotten-export) The symbol "RetryReturn" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface RetryReturnFactory<T, TArgs extends Array<any>>
  extends RetryReturn {
  exec(...args: TArgs): T;
}

// @public (undocumented)
export interface RetryReturnNoFactory extends RetryReturn {
  exec<T>(fn: () => T): T;
}

// @public
export function setI18n<
  T extends i18nDefinition<TMessage>,
  TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>
>(
  definition: T
): i18nResult<
  keyof T["messages"],
  I18nExtractLocale<T["messages"][T["locale"]]>
>;

// @public (undocumented)
export function unwrap<T>(o: RefTyped<T>): T;

// @public (undocumented)
export function useArrayPagination<T extends Array<TR>, TR>(
  array: RefTyped<T>,
  options?: Partial<Omit<PaginationOptions, "total">>
): ArrayPaginationResult<T>;

// @public (undocumented)
export function useCancellablePromise<T extends any, TArgs extends Array<any>>(
  fn: (...args: TArgs) => Promise<T>
): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any, TArgs extends Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  lazy: boolean
): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any, TArgs extends Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any>(
  fn: () => T
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any>(
  fn: () => T,
  lazy: boolean
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends any>(
  fn: () => T,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<
  T extends Promise<TR>,
  TR,
  TArgs extends Array<any>
>(
  fn: (...args: TArgs) => T
): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<
  T extends Promise<TR>,
  TR,
  TArgs extends Array<any>
>(
  fn: (...args: TArgs) => T,
  lazy: boolean
): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<
  T extends Promise<TR>,
  TR,
  TArgs extends Array<any>
>(
  fn: (...args: TArgs) => T,
  options: PromiseOptions
): PromiseResultFactory<T, TArgs> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T = any>(
  fn: () => T
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T = any>(
  fn: () => T,
  lazy: boolean
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T = any>(
  fn: () => T,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>> & CancellablePromiseResult;

// @public (undocumented)
export function useCancellablePromise<T extends Promise<TR>, TR>(
  fn: () => T
): PromiseResultFactory<T> & CancellablePromiseResult;

// @public
export function useDateNow(
  options?: NowOptions
): {
  now: import("@vue/reactivity").Ref<number>;
  remove: () => void;
};

// @public
export function useDebounce<T extends Procedure>(
  handler: T,
  wait?: number,
  options?: Options
): T;

// @public
export function useFormat(
  format: RefTyped<Readonly<string>>,
  obj?: RefTyped<FormatObject>
): Readonly<Ref<string>>;

// @public (undocumented)
export function useFormat(
  format: Readonly<RefTyped<string>>,
  obj?: RefTyped<FormatObject>
): Readonly<Ref<string>>;

// @public
export function useFormat(
  format: Readonly<RefTyped<string>>,
  ...args: Array<FormatValue>
): Readonly<Ref<string>>;

// @public (undocumented)
export function useFormat(
  format: Readonly<RefTyped<string>>,
  obj?: RefTyped<FormatObject> | Array<FormatValue>
): Readonly<Ref<string>>;

// @public (undocumented)
export function useFormat(
  format: RefTyped<string>,
  args: any
): Readonly<Ref<string>>;

// @public
export function useI18n<
  T extends i18nDefinition<TMessage>,
  TMessage extends Record<keyof T["messages"], i18n | (() => Promise<any>)>
>(definition: T): i18nResult<keyof T["messages"], T["messages"][T["locale"]]>;

// @public
export function useI18n<T = i18n>(): i18nResult<string[], T>;

// @public
export function useNow(
  options?: NowOptions & UseNowOptions
): {
  now: import("@vue/reactivity").Ref<number>;
  remove: () => void;
};

// @public (undocumented)
export interface UseNowOptions {
  timeFn?: () => number;
}

// @public
export function usePagination(options: PaginationOptions): PaginationResult;

// @public
export function usePath<T = any, TSource = any>(
  source: RefTyped<TSource>,
  path: RefTyped<string>,
  separator?: string,
  notFoundReturn?: UsePathNotFoundReturn<TSource>
): Ref<Readonly<T>>;

// @public (undocumented)
export type UsePathNotFoundReturn<TSource> = (
  path: string,
  source: any,
  fullPath: string,
  originalSource: TSource
) => any;

// @public
export function usePerformanceNow(
  options?: NowOptions
): {
  now: import("@vue/reactivity").Ref<number>;
  remove: () => void;
};

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  lazy?: boolean
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T,
  lazy: boolean
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => Promise<T>,
  lazy: boolean
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => Promise<T>,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => Promise<T>
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => T,
  lazy: boolean
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => T,
  options: PromiseOptions
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromise<T = any>(
  fn: () => T
): PromiseResultFactory<Promise<T>>;

// @public
export function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>,
  throwException?: boolean
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => Promise<T>
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T,
  throwException: boolean
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromiseLazy<T = any, TArgs extends Array<any> = Array<any>>(
  fn: (...args: TArgs) => T
): PromiseResultFactory<Promise<T>, TArgs>;

// @public (undocumented)
export function usePromiseLazy<T = any>(
  fn: () => Promise<T>,
  throwException: boolean
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromiseLazy<T = any>(
  fn: () => Promise<T>
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromiseLazy<T = any>(
  fn: () => T,
  throwException: boolean
): PromiseResultFactory<Promise<T>>;

// @public (undocumented)
export function usePromiseLazy<T = any>(
  fn: () => T
): PromiseResultFactory<Promise<T>>;

// Warning: (ae-forgotten-export) The symbol "RetryOptions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useRetry(options?: RetryOptions): RetryReturnNoFactory;

// Warning: (ae-forgotten-export) The symbol "Factory" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useRetry<T, TArgs extends Array<any>>(
  factory: Factory<T, TArgs>
): RetryReturnFactory<T, TArgs>;

// @public (undocumented)
export function useRetry<T, TArgs extends Array<any>>(
  options: RetryOptions,
  factory: Factory<T, TArgs>
): RetryReturnFactory<T, TArgs>;

// Warning: (ae-forgotten-export) The symbol "UseValidation" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ValidationOutput" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ValidationGroupResult" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useValidation<T extends UseValidation<E>, E = any>(
  input: E
): ValidationOutput<E> & ValidationGroupResult;

// @public (undocumented)
export function wrap(o: RefElement): Ref<Element>;

// @public (undocumented)
export function wrap<T>(o: RefTyped<T>): Ref<T>;

// @public (undocumented)
export type WrapRef<T> = T extends Ref<any> ? T : Ref<T>;

// (No @packageDocumentation comment for this package)
```
