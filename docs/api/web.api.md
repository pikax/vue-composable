## API Report File for "@vue-composable/web"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { Ref } from "@vue/composition-api";
import { RefElement } from "@vue-composable/core";
import { RefTyped } from "@vue-composable/core";

// @public (undocumented)
export type BreakpointObject = Record<string, string | number>;

// @public (undocumented)
export type BreakpointReturn<T> = Record<keyof T, Ref<boolean>> &
  BreakpointReturnObject<T>;

// @public (undocumented)
export interface BreakpointReturnObject<T> {
  // (undocumented)
  current: Ref<keyof T | undefined>;
  // (undocumented)
  remove: RemoveEventFunction;
}

// @public (undocumented)
export interface BroadcastMessageEvent<T> extends MessageEvent {
  // (undocumented)
  readonly data: T;
}

// @public
export type CssVariable = string | null;

// @public
export type CssVariableConfigurationObject = Record<string, string>;

// @public
export type CssVariableObject<T> = Record<keyof T, Ref<CssVariable>>;

// @public
export interface CssVariablesMethods {
  get: (name: string, element: HTMLElement) => CssVariable;
  resume: () => void;
  set: (name: string, value: CssVariable, element: HTMLElement) => void;
  stop: () => void;
}

// @public (undocumented)
export interface DefaultTailwindBreakpoints {
  // (undocumented)
  lg: 1024;
  // (undocumented)
  md: 768;
  // (undocumented)
  sm: 640;
  // (undocumented)
  xl: 1280;
}

// Warning: (ae-forgotten-export) The symbol "TailwindConfigEmpty" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ExtractTailwindScreens<
  T extends TailwindConfigEmpty
> = keyof T["theme"]["screens"] extends never
  ? DefaultTailwindBreakpoints
  : T["theme"]["screens"];

// @public (undocumented)
export interface GeolocationOptions {
  immediate?: boolean;
}

// @public
export function getVariableFor(
  name: string,
  element?: HTMLElement
): CssVariable;

// @public (undocumented)
export interface IntersectionObserverOptions {
  // (undocumented)
  root?: RefTyped<Element> | null;
  // (undocumented)
  rootMargin?: RefTyped<string> | string;
  // (undocumented)
  threshold?: RefTyped<number | number[]> | number | number[];
}

// @public (undocumented)
export interface IntersectionObserverResult {
  // (undocumented)
  disconnect: () => void;
  // (undocumented)
  elements: Ref<IntersectionObserverEntry[]>;
  // (undocumented)
  readonly isIntersecting: Ref<boolean>;
  // (undocumented)
  observe: (el: RefTyped<Element>) => void;
  // (undocumented)
  supported: boolean;
  // (undocumented)
  unobserve: (el: RefTyped<Element>) => void;
}

// @public (undocumented)
export interface LocalStorageReturn<T> {
  clear: () => void;
  remove: () => void;
  setSync: (sync: boolean) => void;
  // (undocumented)
  storage: Ref<T>;
  // (undocumented)
  supported: boolean;
}

// @public (undocumented)
export type LocalStorageTyped<T extends object> = string;

// @public (undocumented)
export interface MouseMoveResult {
  // (undocumented)
  mouseX: Ref<number>;
  // (undocumented)
  mouseY: Ref<number>;
  // (undocumented)
  remove: RemoveEventFunction;
}

// @public (undocumented)
export interface NetworkInformation {
  // Warning: (ae-forgotten-export) The symbol "NetworkInformationEventMap" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  addEventListener<K extends keyof NetworkInformationEventMap>(
    type: K,
    listener: (
      this: NetworkInformation,
      ev: NetworkInformationEventMap[K]
    ) => any,
    options?: boolean | AddEventListenerOptions
  ): void;
  // (undocumented)
  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void;
  // (undocumented)
  readonly downlink: number;
  // (undocumented)
  readonly downlinkMax: number;
  // Warning: (ae-forgotten-export) The symbol "NetworkInformationEffectiveType" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  readonly effectiveType: NetworkInformationEffectiveType;
  // (undocumented)
  onchange: (this: NetworkInformation, ev: Event) => void;
  // (undocumented)
  removeEventListener<K extends keyof NetworkInformationEventMap>(
    type: K,
    listener: (
      this: NetworkInformation,
      ev: NetworkInformationEventMap[K]
    ) => any,
    options?: boolean | EventListenerOptions
  ): void;
  // (undocumented)
  removeEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void;
  // (undocumented)
  readonly rtt: number;
  // (undocumented)
  readonly saveData: Boolean;
  // Warning: (ae-forgotten-export) The symbol "NetworkInformationType" needs to be exported by the entry point index.d.ts
  //
  // (undocumented)
  readonly type: NetworkInformationType;
}

// @public (undocumented)
export function refShared<T = any>(
  defaultValue?: RefTyped<T>,
  id?: string
): Ref<RefTyped<T>>;

// @public (undocumented)
export type RefSharedMessage<T = any> =
  | RefSharedMessageInit
  | RefSharedMessageSync<T>
  | RefSharedMessageLeave
  | RefSharedMessageUpdate<T>
  | RefSharedMessageSetMind
  | RefSharedMessagePing
  | RefSharedMessagePong;

// @public (undocumented)
export type RefSharedMessageInit = {
  type: RefSharedMessageType.INIT;
};

// @public (undocumented)
export type RefSharedMessageLeave = {
  type: RefSharedMessageType.LEAVE;
  id: number;
};

// @public (undocumented)
export type RefSharedMessagePing = {
  type: RefSharedMessageType.PING;
  id: number;
};

// @public (undocumented)
export type RefSharedMessagePong = {
  type: RefSharedMessageType.PONG;
  id: number;
};

// @public (undocumented)
export type RefSharedMessageSetMind = {
  type: RefSharedMessageType.SET_MIND;
  mind: SharedRefMind;
  id: number;
};

// @public (undocumented)
export type RefSharedMessageSync<T> = {
  type: RefSharedMessageType.SYNC;
  value: T;
  mind: SharedRefMind;
};

// @public (undocumented)
export const enum RefSharedMessageType {
  // (undocumented)
  INIT = 0,
  // (undocumented)
  LEAVE = 4,
  // (undocumented)
  PING = 5,
  // (undocumented)
  PONG = 6,
  // (undocumented)
  SET_MIND = 3,
  // (undocumented)
  SYNC = 1,
  // (undocumented)
  UPDATE = 2
}

// @public (undocumented)
export type RefSharedMessageUpdate<T> = {
  type: RefSharedMessageType.UPDATE;
  value: T;
  mind: SharedRefMind;
};

// @public (undocumented)
export type RemoveEventFunction = () => void;

// @public (undocumented)
export interface ResizeResult {
  // (undocumented)
  height: Ref<number>;
  // (undocumented)
  remove: RemoveEventFunction;
  // (undocumented)
  width: Ref<number>;
}

// @public (undocumented)
export interface ScrollResult {
  // (undocumented)
  remove: RemoveEventFunction;
  // (undocumented)
  scrollLeft: Ref<number>;
  // (undocumented)
  scrollLeftTo: (x: number) => void;
  // (undocumented)
  scrollTo: Element["scrollTo"];
  // (undocumented)
  scrollTop: Ref<number>;
  // (undocumented)
  scrollTopTo: (y: number) => void;
}

// @public (undocumented)
export function setBreakpointTailwindCSS<T extends TailwindConfigEmpty>(
  tailwindConfig: T
): BreakpointReturn<ExtractTailwindScreens<T>>;

// @public (undocumented)
export function setBreakpointTailwindCSS<T extends BreakpointObject>(
  breakpoints: T
): BreakpointReturn<T>;

// @public
export function setVariableFor(
  name: string,
  value: CssVariable,
  element?: HTMLElement
): void;

// @public (undocumented)
export const enum SharedRefMind {
  // (undocumented)
  HIVE = 0,
  // (undocumented)
  MASTER = 1
}

// @public (undocumented)
export function storageAvailable(storage?: Storage): boolean;

// @public (undocumented)
export interface StorageSerializer<T = any> {
  // (undocumented)
  parse(data: string): T;
  // (undocumented)
  stringify(item: T): string;
}

// @public (undocumented)
export function useBreakpoint<T extends BreakpointObject>(
  breakpoints: Record<keyof T, number | string>
): BreakpointReturn<T>;

// Warning: (ae-forgotten-export) The symbol "ChromeBreakpoint" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useBreakpointChrome(): BreakpointReturn<ChromeBreakpoint>;

// @public (undocumented)
export function useBreakpointTailwindCSS<T extends TailwindConfigEmpty>(
  tailwindConfig: T
): BreakpointReturn<ExtractTailwindScreens<T>>;

// @public (undocumented)
export function useBreakpointTailwindCSS<
  T extends TailwindConfigEmpty
>(): BreakpointReturn<ExtractTailwindScreens<T>>;

// @public (undocumented)
export function useBreakpointTailwindCSS(): BreakpointReturn<
  DefaultTailwindBreakpoints
>;

// @public (undocumented)
export function useBreakpointTailwindCSS<
  T extends BreakpointObject
>(): BreakpointReturn<T>;

// @public (undocumented)
export function useBroadcastChannel<T = any>(
  name: string,
  onBeforeClose?: Function
): {
  supported: boolean;
  data: import("@vue/composition-api").Ref<T | null>;
  messageEvent: import("@vue/composition-api").Ref<MessageEvent | null>;
  errorEvent: import("@vue/composition-api").Ref<MessageEvent | null>;
  errored: import("@vue/composition-api").Ref<boolean>;
  isClosed: import("@vue/composition-api").Ref<boolean>;
  send: (data: T) => void;
  close: Function;
  addListener: (
    cb: (ev: BroadcastMessageEvent<T>) => void,
    options?: boolean | AddEventListenerOptions | undefined
  ) => void;
};

// @public
export type UseCssVariables<T> = CssVariableObject<T> & CssVariablesMethods;

// @public (undocumented)
export function useCssVariables<T extends CssVariableConfigurationObject>(
  variables: Record<keyof T, string>,
  element?: HTMLElement
): UseCssVariables<T>;

// @public (undocumented)
export function useEvent<
  T extends {
    addEventListener: (
      name: string,
      listener: EventListenerOrEventListenerObject
    ) => any;
    removeEventListener: Function;
  },
  M,
  K extends keyof M
>(
  el: RefTyped<T>,
  name: K,
  listener: (this: T, ev: M[K]) => any
): RemoveEventFunction;

// @public (undocumented)
export function useEvent<
  T extends {
    addEventListener: (
      name: string,
      listener: EventListenerOrEventListenerObject,
      options?: boolean | AddEventListenerOptions
    ) => any;
    removeEventListener: Function;
  },
  M,
  K extends keyof M
>(
  el: RefTyped<T>,
  name: K,
  listener: (this: T, ev: M[K]) => any,
  options?: boolean | AddEventListenerOptions
): RemoveEventFunction;

// @public (undocumented)
export function useEvent<K extends keyof WindowEventMap>(
  el: RefTyped<Window>,
  name: K,
  listener: (this: Document, ev: WindowEventMap[K]) => any,
  options?: boolean | AddEventListenerOptions
): RemoveEventFunction;

// @public (undocumented)
export function useEvent<K extends keyof DocumentEventMap>(
  el: RefTyped<Element>,
  name: K,
  listener: (this: Document, ev: DocumentEventMap[K]) => any,
  options?: boolean | AddEventListenerOptions
): RemoveEventFunction;

// @public (undocumented)
export function useFetch<T = any>(
  options?: UseFetchOptions & Partial<RequestInfo>,
  requestInit?: RequestInit
): {
  cancel: (message?: string | undefined) => void;
  isCancelled: import("@vue/composition-api").Ref<boolean>;
  cancelledMessage: import("@vue/composition-api").Ref<string | undefined>;
  text: import("@vue/composition-api").Ref<string>;
  blob: import("@vue/composition-api").Ref<Blob | undefined>;
  json: import("@vue/composition-api").Ref<T | null>;
  jsonError: import("@vue/composition-api").Ref<any>;
  status: Readonly<import("@vue/composition-api").Ref<number | null>>;
  statusText: Readonly<import("@vue/composition-api").Ref<string | null>>;
  exec: (
    request: RequestInfo,
    init?: RequestInit | undefined
  ) => Promise<Response | undefined>;
  promise: import("@vue/composition-api").Ref<Promise<Response> | undefined>
  /**
   * @description if the value is `true` it will parse the `json` before resolving the promise
   * @default true
   */;
  result: import("@vue/composition-api").Ref<Response | null>;
  loading: import("@vue/composition-api").Ref<boolean>;
  error: import("@vue/composition-api").Ref<any>;
};

// @public (undocumented)
export interface UseFetchOptions {
  isJson?: boolean;
  parseImmediate?: boolean;
}

// @public (undocumented)
export function useGeolocation(
  options?: PositionOptions & GeolocationOptions
): {
  supported: boolean;
  refresh: () => void;
  error: import("@vue/composition-api").Ref<PositionError | null>;
  timestamp: import("@vue/composition-api").Ref<number | null>;
  coords: import("@vue/composition-api").Ref<Coordinates | null>;
  highAccuracy: import("@vue/composition-api").Ref<boolean>;
};

// @public (undocumented)
export function useIntersectionObserver(
  el: RefElement,
  options?: RefTyped<IntersectionObserverOptions>
): IntersectionObserverResult;

// @public (undocumented)
export function useIntersectionObserver(
  options: RefTyped<IntersectionObserverOptions>
): IntersectionObserverResult;

// @public (undocumented)
export function useLanguage(): {
  language: Ref<String>;
  languages: Ref<readonly String[]>;
};

// @public (undocumented)
export function useLocalStorage(
  key: string,
  defaultValue?: RefTyped<string>,
  sync?: boolean
): LocalStorageReturn<string>;

// @public (undocumented)
export function useLocalStorage<T extends object = any>(
  key: LocalStorageTyped<T> | string,
  defaultValue?: RefTyped<T>,
  sync?: boolean
): LocalStorageReturn<T>;

// @public (undocumented)
export function useMatchMedia(
  query: string
): {
  supported: boolean;
  mediaQueryList: Ref<MediaQueryList>;
  matches: Ref<boolean>;
  remove: () => void;
};

// Warning: (ae-forgotten-export) The symbol "NetworkInformationReturn" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useNetworkInformation(): NetworkInformationReturn;

// @public (undocumented)
export function useOnline(): {
  supported: boolean;
  online: Ref<boolean>;
};

// @public (undocumented)
export function useOnMouseMove(
  el: RefTyped<Window>,
  wait: number
): MouseMoveResult;

// @public (undocumented)
export function useOnMouseMove(
  el: RefTyped<Window>,
  options?: boolean | AddEventListenerOptions,
  wait?: number
): MouseMoveResult;

// @public (undocumented)
export function useOnMouseMove(el: RefElement, wait: number): MouseMoveResult;

// @public (undocumented)
export function useOnMouseMove(
  el: RefElement,
  options?: boolean | AddEventListenerOptions,
  wait?: number
): MouseMoveResult;

// @public (undocumented)
export function useOnResize(el: RefTyped<Window>, wait: number): ResizeResult;

// @public (undocumented)
export function useOnResize(
  el: RefTyped<Window>,
  options?: boolean | AddEventListenerOptions,
  wait?: number
): ResizeResult;

// @public (undocumented)
export function useOnResize(el: RefElement, wait: number): ResizeResult;

// @public (undocumented)
export function useOnResize(
  el: RefElement,
  options?: boolean | AddEventListenerOptions,
  wait?: number
): ResizeResult;

// @public (undocumented)
export function useOnScroll(): ScrollResult;

// @public (undocumented)
export function useOnScroll(wait: number): ScrollResult;

// @public (undocumented)
export function useOnScroll(
  options: boolean | AddEventListenerOptions,
  wait?: number
): ScrollResult;

// @public (undocumented)
export function useOnScroll(el: RefTyped<Window>, wait: number): ScrollResult;

// @public (undocumented)
export function useOnScroll(
  el: RefTyped<Window>,
  options?: boolean | AddEventListenerOptions,
  wait?: number
): ScrollResult;

// @public (undocumented)
export function useOnScroll(el: RefElement, wait: number): ScrollResult;

// @public (undocumented)
export function useOnScroll(
  el: RefElement,
  options?: boolean | AddEventListenerOptions,
  wait?: number
): ScrollResult;

// @public (undocumented)
export function usePageVisibility(): {
  visibility: Ref<VisibilityState>;
  hidden: Ref<boolean>;
};

// @public (undocumented)
export function useSessionStorage(
  key: string,
  defaultValue?: RefTyped<string>,
  sync?: boolean
): LocalStorageReturn<string>;

// @public (undocumented)
export function useSessionStorage<T extends object = object>(
  key: LocalStorageTyped<T> | string,
  defaultValue?: RefTyped<T>,
  sync?: boolean
): LocalStorageReturn<T>;

// @public (undocumented)
export function useSharedRef<T = any>(
  name: string,
  defaultValue?: T
): {
  supported: boolean;
  id: number;
  data: Ref<T>;
  master: Ref<boolean>;
  mind: Ref<SharedRefMind>;
  editable: Readonly<Ref<boolean>>;
  targets: Ref<number[]>;
  ping: () => void;
  setMind: (t: SharedRefMind) => void;
  addListener: (
    cb: (ev: BroadcastMessageEvent<RefSharedMessage<T>>) => void,
    options?: boolean | AddEventListenerOptions | undefined
  ) => void;
};

// @public (undocumented)
export function useStorage(
  key: string,
  defaultValue?: RefTyped<string>,
  sync?: boolean
): LocalStorageReturn<string>;

// @public (undocumented)
export function useStorage<T extends object = any>(
  key: LocalStorageTyped<T> | string,
  defaultValue?: RefTyped<T>,
  sync?: boolean
): LocalStorageReturn<T>;

// @public (undocumented)
export function useWebSocket(
  url: string,
  protocols?: string | string[]
): {
  supported: boolean;
  ws: WebSocket | null;
  send: (
    data: string | ArrayBuffer | SharedArrayBuffer | Blob | ArrayBufferView
  ) => void;
  close: (code?: number | undefined, reason?: string | undefined) => void;
  messageEvent: import("@vue/composition-api").Ref<MessageEvent | null>;
  errorEvent: import("@vue/composition-api").Ref<Event | undefined>;
  data: import("@vue/composition-api").Ref<any>;
  isOpen: import("@vue/composition-api").Ref<boolean>;
  isClosed: import("@vue/composition-api").Ref<boolean>;
  errored: import("@vue/composition-api").Ref<boolean>;
};

// Warning: (ae-forgotten-export) The symbol "WebStorageType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function useWebStorage(
  type: WebStorageType,
  serializer?: StorageSerializer,
  ms?: number
): {
  supported: boolean;
  quotaError: Ref<boolean>;
  store: WebStorage;
  remove: () => boolean;
};

// @public (undocumented)
export interface WebStorage {
  // (undocumented)
  $quotaError: Ref<boolean>;
  // (undocumented)
  $refMap: Map<string, Ref<any>>;
  // (undocumented)
  $syncKeys: Record<string, boolean>;
  // (undocumented)
  $watchHandlers: Map<string, Function>;
  clear(): void;
  getItem<T = any>(key: string): Ref<T> | null;
  key(index: number): string | null;
  readonly length: number;
  removeItem(key: string): void;
  setItem<T>(key: string, value: T): Ref<T>;
  // (undocumented)
  setSync(key: string, sync: boolean): void;
  // (undocumented)
  updateItem(key: string, value: string): void;
}

// (No @packageDocumentation comment for this package)
```
